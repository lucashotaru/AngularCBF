import { DOCUMENT } from '@angular/common';
import { Directive, Inject, } from '@angular/core';
import { merge, Subject } from 'rxjs';
import { distinctUntilChanged, map, takeUntil, filter } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/scrolling";
import * as i2 from "@angular/cdk/platform";
export class NgxNavbarDynamicExpandDirective {
    constructor(viewportRuler, elRef, ngZone, cdRef, platform, _document) {
        this.viewportRuler = viewportRuler;
        this.elRef = elRef;
        this.ngZone = ngZone;
        this.cdRef = cdRef;
        this.platform = platform;
        this._document = _document;
        this.onDestroy$ = new Subject();
        this.update$ = new Subject();
        this.loaded = false;
        this._isExpanded = false;
        this.ngZone.runOutsideAngular(() => {
            merge(this.viewportRuler.change(150), this.update$)
                .pipe(filter(() => this.loaded ||
                (this.loaded = checkBootstrapStylesAreLoaded(this._document, this.elRef.nativeElement))), map(() => {
                const element = this.elRef.nativeElement;
                let overflowSize;
                if (this.isExpanded) {
                    overflowSize = element.scrollWidth - element.offsetWidth;
                }
                else {
                    const clone = element.cloneNode(true);
                    clone.classList.add('navbar-expand');
                    const parent = element.parentElement;
                    if (parent) {
                        parent.appendChild(clone);
                        overflowSize = clone.scrollWidth - clone.offsetWidth;
                        parent.removeChild(clone);
                    }
                }
                return !overflowSize;
            }), distinctUntilChanged(), takeUntil(this.onDestroy$))
                .subscribe((isExpanded) => {
                this.ngZone.run(() => {
                    this._isExpanded = isExpanded;
                    this.cdRef.markForCheck();
                });
            });
        });
    }
    get isExpanded() {
        return this._isExpanded;
    }
    ngAfterContentInit() {
        if (!this.platform.isBrowser) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            this.loaded = checkBootstrapStylesAreLoaded(this._document, this.elRef.nativeElement);
            if (this.loaded) {
                this.update$.next();
            }
            else {
                setTimeout(() => {
                    this.ngAfterContentInit();
                }, 1000 / 60);
            }
        });
    }
    ngOnDestroy() {
        this.update$.complete();
        this.onDestroy$.next();
        this.onDestroy$.complete();
    }
}
NgxNavbarDynamicExpandDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.0", ngImport: i0, type: NgxNavbarDynamicExpandDirective, deps: [{ token: i1.ViewportRuler }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }, { token: i2.Platform }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Directive });
NgxNavbarDynamicExpandDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.0.0", type: NgxNavbarDynamicExpandDirective, selector: "[ngxNavbarDynamicExpand]", host: { properties: { "class.navbar-expand": "isExpanded" }, classAttribute: "navbar text-nowrap" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.0", ngImport: i0, type: NgxNavbarDynamicExpandDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngxNavbarDynamicExpand]',
                    host: {
                        class: 'navbar text-nowrap',
                        '[class.navbar-expand]': 'isExpanded',
                    },
                }]
        }], ctorParameters: function () { return [{ type: i1.ViewportRuler }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: i2.Platform }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }]; } });
function checkBootstrapStylesAreLoaded(document, element) {
    const documentWindow = document.defaultView || window;
    const computedStyle = documentWindow && documentWindow.getComputedStyle
        ? documentWindow.getComputedStyle(element)
        : false;
    return computedStyle && computedStyle.whiteSpace === 'nowrap';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2YmFyLWR5bmFtaWMtY29sbGFwc2UuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LWJvb3RzdHJhcC1uYXZiYXIvc3JjL2xpYi9uYXZiYXItZHluYW1pYy1jb2xsYXBzZS5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzNDLE9BQU8sRUFFTCxTQUFTLEVBS1QsTUFBTSxHQUNQLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7O0FBUzlFLE1BQU0sT0FBTywrQkFBK0I7SUFXMUMsWUFDbUIsYUFBNEIsRUFDNUIsS0FBOEIsRUFDOUIsTUFBYyxFQUNkLEtBQXdCLEVBQ3hCLFFBQWtCLEVBQ0EsU0FBbUI7UUFMckMsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFDNUIsVUFBSyxHQUFMLEtBQUssQ0FBeUI7UUFDOUIsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQUNkLFVBQUssR0FBTCxLQUFLLENBQW1CO1FBQ3hCLGFBQVEsR0FBUixRQUFRLENBQVU7UUFDQSxjQUFTLEdBQVQsU0FBUyxDQUFVO1FBZHZDLGVBQVUsR0FBRyxJQUFJLE9BQU8sRUFBUSxDQUFDO1FBQ2pDLFlBQU8sR0FBRyxJQUFJLE9BQU8sRUFBUSxDQUFDO1FBQ3ZDLFdBQU0sR0FBRyxLQUFLLENBQUM7UUFDZixnQkFBVyxHQUFHLEtBQUssQ0FBQztRQWExQixJQUFJLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsRUFBRTtZQUNqQyxLQUFLLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsR0FBRyxD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RTt3QkFDSixLQUFLLEVBQUUsb0JBQW9CO3dCQUMzQix1QkFBdUIsRUFBRSxZQUFZO3FCQUN0QztpQkFDRjsyTEFrQmlELFFBQVE7MEJBQXJELE1BQU07MkJBQUMsUUFBUTs7QUFvRXBCLFNBQVMsNkJBQTZCLENBQ3BDLFFBQWtCLEVBQ2xCLE9BQWdCO0lBRWhCLE1BQU0sY0FBYyxHQUFHLFFBQVEsQ0FBQyxXQUFXLElBQUksTUFBTSxDQUFDO0lBQ3RELE1BQU0sYUFBYSxHQUNqQixjQUFjLElBQUksY0FBYyxDQUFDLGdCQUFnQjtRQUMvQyxDQUFDLENBQUMsY0FBYyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQztRQUMxQyxDQUFDLENBQUMsS0FBSyxDQUFDO0lBQ1osT0FBTyxhQUFhLElBQUksYUFBYSxDQUFDLFVBQVUsS0FBSyxRQUFRLENBQUM7QUFDaEUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBsYXRmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BsYXRmb3JtJztcclxuaW1wb3J0IHsgVmlld3BvcnRSdWxlciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9zY3JvbGxpbmcnO1xyXG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7XHJcbiAgQWZ0ZXJDb250ZW50SW5pdCxcclxuICBEaXJlY3RpdmUsXHJcbiAgRWxlbWVudFJlZixcclxuICBOZ1pvbmUsXHJcbiAgT25EZXN0cm95LFxyXG4gIENoYW5nZURldGVjdG9yUmVmLFxyXG4gIEluamVjdCxcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgbWVyZ2UsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQsIG1hcCwgdGFrZVVudGlsLCBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICBzZWxlY3RvcjogJ1tuZ3hOYXZiYXJEeW5hbWljRXhwYW5kXScsXHJcbiAgaG9zdDoge1xyXG4gICAgY2xhc3M6ICduYXZiYXIgdGV4dC1ub3dyYXAnLFxyXG4gICAgJ1tjbGFzcy5uYXZiYXItZXhwYW5kXSc6ICdpc0V4cGFuZGVkJyxcclxuICB9LFxyXG59KVxyXG5leHBvcnQgY2xhc3MgTmd4TmF2YmFyRHluYW1pY0V4cGFuZERpcmVjdGl2ZVxyXG4gIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95XHJcbntcclxuICBwcml2YXRlIHJlYWRvbmx5IG9uRGVzdHJveSQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgdXBkYXRlJCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XHJcbiAgcHJpdmF0ZSBsb2FkZWQgPSBmYWxzZTtcclxuICBwcml2YXRlIF9pc0V4cGFuZGVkID0gZmFsc2U7XHJcbiAgZ2V0IGlzRXhwYW5kZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faXNFeHBhbmRlZDtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgcHJpdmF0ZSByZWFkb25seSB2aWV3cG9ydFJ1bGVyOiBWaWV3cG9ydFJ1bGVyLFxyXG4gICAgcHJpdmF0ZSByZWFkb25seSBlbFJlZjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IG5nWm9uZTogTmdab25lLFxyXG4gICAgcHJpdmF0ZSByZWFkb25seSBjZFJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IHBsYXRmb3JtOiBQbGF0Zm9ybSxcclxuICAgIEBJbmplY3QoRE9DVU1FTlQpIHByaXZhdGUgcmVhZG9ubHkgX2RvY3VtZW50OiBEb2N1bWVudFxyXG4gICkge1xyXG4gICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xyXG4gICAgICBtZXJnZSh0aGlzLnZpZXdwb3J0UnVsZXIuY2hhbmdlKDE1MCksIHRoaXMudXBkYXRlJClcclxuICAgICAgICAucGlwZShcclxuICAgICAgICAgIGZpbHRlcihcclxuICAgICAgICAgICAgKCkgPT5cclxuICAgICAgICAgICAgICB0aGlzLmxvYWRlZCB8fFxyXG4gICAgICAgICAgICAgICh0aGlzLmxvYWRlZCA9IGNoZWNrQm9vdHN0cmFwU3R5bGVzQXJlTG9hZGVkKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZG9jdW1lbnQsXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsUmVmLm5hdGl2ZUVsZW1lbnRcclxuICAgICAgICAgICAgICApKVxyXG4gICAgICAgICAgKSxcclxuICAgICAgICAgIG1hcCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsUmVmLm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGxldCBvdmVyZmxvd1NpemU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRXhwYW5kZWQpIHtcclxuICAgICAgICAgICAgICBvdmVyZmxvd1NpemUgPSBlbGVtZW50LnNjcm9sbFdpZHRoIC0gZWxlbWVudC5vZmZzZXRXaWR0aDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBjb25zdCBjbG9uZSA9IGVsZW1lbnQuY2xvbmVOb2RlKHRydWUpIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgICAgICAgIGNsb25lLmNsYXNzTGlzdC5hZGQoJ25hdmJhci1leHBhbmQnKTtcclxuICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGNsb25lKTtcclxuICAgICAgICAgICAgICAgIG92ZXJmbG93U2l6ZSA9IGNsb25lLnNjcm9sbFdpZHRoIC0gY2xvbmUub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY2xvbmUpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gIW92ZXJmbG93U2l6ZTtcclxuICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcclxuICAgICAgICAgIHRha2VVbnRpbCh0aGlzLm9uRGVzdHJveSQpXHJcbiAgICAgICAgKVxyXG4gICAgICAgIC5zdWJzY3JpYmUoKGlzRXhwYW5kZWQpID0+IHtcclxuICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzRXhwYW5kZWQgPSBpc0V4cGFuZGVkO1xyXG4gICAgICAgICAgICB0aGlzLmNkUmVmLm1hcmtGb3JDaGVjaygpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcclxuICAgIGlmICghdGhpcy5wbGF0Zm9ybS5pc0Jyb3dzZXIpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xyXG4gICAgICB0aGlzLmxvYWRlZCA9IGNoZWNrQm9vdHN0cmFwU3R5bGVzQXJlTG9hZGVkKFxyXG4gICAgICAgIHRoaXMuX2RvY3VtZW50LFxyXG4gICAgICAgIHRoaXMuZWxSZWYubmF0aXZlRWxlbWVudFxyXG4gICAgICApO1xyXG4gICAgICBpZiAodGhpcy5sb2FkZWQpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSQubmV4dCgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5uZ0FmdGVyQ29udGVudEluaXQoKTtcclxuICAgICAgICB9LCAxMDAwIC8gNjApO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIG5nT25EZXN0cm95KCkge1xyXG4gICAgdGhpcy51cGRhdGUkLmNvbXBsZXRlKCk7XHJcbiAgICB0aGlzLm9uRGVzdHJveSQubmV4dCgpO1xyXG4gICAgdGhpcy5vbkRlc3Ryb3kkLmNvbXBsZXRlKCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja0Jvb3RzdHJhcFN0eWxlc0FyZUxvYWRlZChcclxuICBkb2N1bWVudDogRG9jdW1lbnQsXHJcbiAgZWxlbWVudDogRWxlbWVudFxyXG4pOiBib29sZWFuIHtcclxuICBjb25zdCBkb2N1bWVudFdpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcclxuICBjb25zdCBjb21wdXRlZFN0eWxlID1cclxuICAgIGRvY3VtZW50V2luZG93ICYmIGRvY3VtZW50V2luZG93LmdldENvbXB1dGVkU3R5bGVcclxuICAgICAgPyBkb2N1bWVudFdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpXHJcbiAgICAgIDogZmFsc2U7XHJcbiAgcmV0dXJuIGNvbXB1dGVkU3R5bGUgJiYgY29tcHV0ZWRTdHlsZS53aGl0ZVNwYWNlID09PSAnbm93cmFwJztcclxufVxyXG4iXX0=