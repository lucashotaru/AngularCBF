{"ast":null,"code":"import { Directionality, BidiModule } from '@angular/cdk/bidi';\nimport { Platform, PlatformModule } from '@angular/cdk/platform';\nimport { CommonModule } from '@angular/common';\nimport { Directive, ElementRef, Renderer2, InjectionToken, EventEmitter, Component, ChangeDetectionStrategy, ViewEncapsulation, NgZone, ChangeDetectorRef, Optional, Inject, ContentChildren, ViewChild, Input, Output, NgModule } from '@angular/core';\nimport { __decorate } from 'tslib';\nimport { LEFT_ARROW, RIGHT_ARROW } from '@angular/cdk/keycodes';\nimport { Subject, fromEvent, timer } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport { NzConfigService, WithConfig } from 'ng-zorro-antd/core/config';\nimport { NzResizeService, NzDragService } from 'ng-zorro-antd/core/services';\nimport { InputBoolean, InputNumber } from 'ng-zorro-antd/core/util';\n/**\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\r\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from 'ng-zorro-antd/core/config';\nimport * as ɵngcc2 from '@angular/cdk/platform';\nimport * as ɵngcc3 from 'ng-zorro-antd/core/services';\nimport * as ɵngcc4 from '@angular/cdk/bidi';\nimport * as ɵngcc5 from '@angular/common';\nconst _c0 = [\"slickList\"];\nconst _c1 = [\"slickTrack\"];\n\nfunction NzCarouselComponent_ul_6_li_1_ng_template_1_Template(rf, ctx) {}\n\nconst _c2 = function (a0) {\n  return {\n    $implicit: a0\n  };\n};\n\nfunction NzCarouselComponent_ul_6_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r10 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"li\", 9);\n    ɵngcc0.ɵɵlistener(\"click\", function NzCarouselComponent_ul_6_li_1_Template_li_click_0_listener() {\n      const restoredCtx = ɵngcc0.ɵɵrestoreView(_r10);\n      const i_r7 = restoredCtx.index;\n      const ctx_r9 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r9.onLiClick(i_r7);\n    });\n    ɵngcc0.ɵɵtemplate(1, NzCarouselComponent_ul_6_li_1_ng_template_1_Template, 0, 0, \"ng-template\", 10);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const i_r7 = ctx.index;\n    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);\n\n    const _r3 = ɵngcc0.ɵɵreference(8);\n\n    ɵngcc0.ɵɵclassProp(\"slick-active\", i_r7 === ctx_r5.activeIndex);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r5.nzDotRender || _r3)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(4, _c2, i_r7));\n  }\n}\n\nfunction NzCarouselComponent_ul_6_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"ul\", 7);\n    ɵngcc0.ɵɵtemplate(1, NzCarouselComponent_ul_6_li_1_Template, 2, 6, \"li\", 8);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassProp(\"slick-dots-top\", ctx_r2.nzDotPosition === \"top\")(\"slick-dots-bottom\", ctx_r2.nzDotPosition === \"bottom\")(\"slick-dots-left\", ctx_r2.nzDotPosition === \"left\")(\"slick-dots-right\", ctx_r2.nzDotPosition === \"right\");\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r2.carouselContents);\n  }\n}\n\nfunction NzCarouselComponent_ng_template_7_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"button\");\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const index_r11 = ctx.$implicit;\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(index_r11 + 1);\n  }\n}\n\nconst _c3 = [\"*\"];\nlet NzCarouselContentDirective = /*#__PURE__*/(() => {\n  class NzCarouselContentDirective {\n    constructor(elementRef, renderer) {\n      this.renderer = renderer;\n      this._active = false;\n      this.el = elementRef.nativeElement;\n      this.renderer.addClass(elementRef.nativeElement, 'slick-slide');\n    }\n\n    set isActive(value) {\n      this._active = value;\n\n      if (this.isActive) {\n        this.renderer.addClass(this.el, 'slick-active');\n      } else {\n        this.renderer.removeClass(this.el, 'slick-active');\n      }\n    }\n\n    get isActive() {\n      return this._active;\n    }\n\n  }\n\n  NzCarouselContentDirective.ɵfac = function NzCarouselContentDirective_Factory(t) {\n    return new (t || NzCarouselContentDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  NzCarouselContentDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: NzCarouselContentDirective,\n    selectors: [[\"\", \"nz-carousel-content\", \"\"]],\n    exportAs: [\"nzCarouselContent\"]\n  });\n  return NzCarouselContentDirective;\n})();\n\n/**\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\r\n */\nclass NzCarouselBaseStrategy {\n  constructor(carouselComponent, cdr, renderer, platform, options) {\n    this.cdr = cdr;\n    this.renderer = renderer;\n    this.platform = platform;\n    this.options = options;\n    this.carouselComponent = carouselComponent;\n  }\n\n  get maxIndex() {\n    return this.length - 1;\n  }\n\n  get firstEl() {\n    return this.contents[0].el;\n  }\n\n  get lastEl() {\n    return this.contents[this.maxIndex].el;\n  }\n  /**\r\n   * Initialize dragging sequences.\r\n   *\r\n   * @param contents\r\n   */\n\n\n  withCarouselContents(contents) {\n    const carousel = this.carouselComponent;\n    this.slickListEl = carousel.slickListEl;\n    this.slickTrackEl = carousel.slickTrackEl;\n    this.contents = (contents === null || contents === void 0 ? void 0 : contents.toArray()) || [];\n    this.length = this.contents.length;\n\n    if (this.platform.isBrowser) {\n      const rect = carousel.el.getBoundingClientRect();\n      this.unitWidth = rect.width;\n      this.unitHeight = rect.height;\n    } else {\n      // Since we cannot call getBoundingClientRect in server, we just hide all items except for the first one.\n      contents === null || contents === void 0 ? void 0 : contents.forEach((content, index) => {\n        if (index === 0) {\n          this.renderer.setStyle(content.el, 'width', '100%');\n        } else {\n          this.renderer.setStyle(content.el, 'display', 'none');\n        }\n      });\n    }\n  }\n  /**\r\n   * When user drag the carousel component.\r\n   *\r\n   * @optional\r\n   */\n\n\n  dragging(_vector) {}\n  /**\r\n   * Destroy a scroll strategy.\r\n   */\n\n\n  dispose() {}\n\n  getFromToInBoundary(f, t) {\n    const length = this.maxIndex + 1;\n    return {\n      from: (f + length) % length,\n      to: (t + length) % length\n    };\n  }\n\n}\n/**\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\r\n */\n\n\nclass NzCarouselOpacityStrategy extends NzCarouselBaseStrategy {\n  withCarouselContents(contents) {\n    super.withCarouselContents(contents);\n\n    if (this.contents) {\n      this.slickTrackEl.style.width = `${this.length * this.unitWidth}px`;\n      this.contents.forEach((content, i) => {\n        this.renderer.setStyle(content.el, 'opacity', this.carouselComponent.activeIndex === i ? '1' : '0');\n        this.renderer.setStyle(content.el, 'position', 'relative');\n        this.renderer.setStyle(content.el, 'width', `${this.unitWidth}px`);\n        this.renderer.setStyle(content.el, 'left', `${-this.unitWidth * i}px`);\n        this.renderer.setStyle(content.el, 'transition', ['opacity 500ms ease 0s', 'visibility 500ms ease 0s']);\n      });\n    }\n  }\n\n  switch(_f, _t) {\n    const {\n      to: t\n    } = this.getFromToInBoundary(_f, _t);\n    const complete$ = new Subject();\n    this.contents.forEach((content, i) => {\n      this.renderer.setStyle(content.el, 'opacity', t === i ? '1' : '0');\n    });\n    setTimeout(() => {\n      complete$.next();\n      complete$.complete();\n    }, this.carouselComponent.nzTransitionSpeed);\n    return complete$;\n  }\n\n  dispose() {\n    this.contents.forEach(content => {\n      this.renderer.setStyle(content.el, 'transition', null);\n      this.renderer.setStyle(content.el, 'opacity', null);\n      this.renderer.setStyle(content.el, 'width', null);\n      this.renderer.setStyle(content.el, 'left', null);\n    });\n    super.dispose();\n  }\n\n}\n/**\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\r\n */\n\n\nclass NzCarouselTransformStrategy extends NzCarouselBaseStrategy {\n  constructor(carouselComponent, cdr, renderer, platform, options) {\n    super(carouselComponent, cdr, renderer, platform, options);\n    this.isDragging = false;\n    this.isTransitioning = false;\n  }\n\n  get vertical() {\n    return this.carouselComponent.vertical;\n  }\n\n  dispose() {\n    super.dispose();\n    this.renderer.setStyle(this.slickTrackEl, 'transform', null);\n  }\n\n  withCarouselContents(contents) {\n    super.withCarouselContents(contents);\n    const carousel = this.carouselComponent;\n    const activeIndex = carousel.activeIndex; // We only do when we are in browser.\n\n    if (this.platform.isBrowser && this.contents.length) {\n      this.renderer.setStyle(this.slickListEl, 'height', `${this.unitHeight}px`);\n\n      if (this.vertical) {\n        this.renderer.setStyle(this.slickTrackEl, 'width', `${this.unitWidth}px`);\n        this.renderer.setStyle(this.slickTrackEl, 'height', `${this.length * this.unitHeight}px`);\n        this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(0, ${-activeIndex * this.unitHeight}px, 0)`);\n      } else {\n        this.renderer.setStyle(this.slickTrackEl, 'height', `${this.unitHeight}px`);\n        this.renderer.setStyle(this.slickTrackEl, 'width', `${this.length * this.unitWidth}px`);\n        this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(${-activeIndex * this.unitWidth}px, 0, 0)`);\n      }\n\n      this.contents.forEach(content => {\n        this.renderer.setStyle(content.el, 'position', 'relative');\n        this.renderer.setStyle(content.el, 'width', `${this.unitWidth}px`);\n        this.renderer.setStyle(content.el, 'height', `${this.unitHeight}px`);\n      });\n    }\n  }\n\n  switch(_f, _t) {\n    const {\n      to: t\n    } = this.getFromToInBoundary(_f, _t);\n    const complete$ = new Subject();\n    this.renderer.setStyle(this.slickTrackEl, 'transition', `transform ${this.carouselComponent.nzTransitionSpeed}ms ease`);\n\n    if (this.vertical) {\n      this.verticalTransform(_f, _t);\n    } else {\n      this.horizontalTransform(_f, _t);\n    }\n\n    this.isTransitioning = true;\n    this.isDragging = false; // TODO@wendellhu95: use transitionEnd event instead of setTimeout\n\n    setTimeout(() => {\n      this.renderer.setStyle(this.slickTrackEl, 'transition', null);\n      this.contents.forEach(content => {\n        this.renderer.setStyle(content.el, this.vertical ? 'top' : 'left', null);\n      });\n\n      if (this.vertical) {\n        this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(0, ${-t * this.unitHeight}px, 0)`);\n      } else {\n        this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(${-t * this.unitWidth}px, 0, 0)`);\n      }\n\n      this.isTransitioning = false;\n      complete$.next();\n      complete$.complete();\n    }, this.carouselComponent.nzTransitionSpeed);\n    return complete$.asObservable();\n  }\n\n  dragging(_vector) {\n    if (this.isTransitioning) {\n      return;\n    }\n\n    const activeIndex = this.carouselComponent.activeIndex;\n\n    if (this.carouselComponent.vertical) {\n      if (!this.isDragging && this.length > 2) {\n        if (activeIndex === this.maxIndex) {\n          this.prepareVerticalContext(true);\n        } else if (activeIndex === 0) {\n          this.prepareVerticalContext(false);\n        }\n      }\n\n      this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(0, ${-activeIndex * this.unitHeight + _vector.x}px, 0)`);\n    } else {\n      if (!this.isDragging && this.length > 2) {\n        if (activeIndex === this.maxIndex) {\n          this.prepareHorizontalContext(true);\n        } else if (activeIndex === 0) {\n          this.prepareHorizontalContext(false);\n        }\n      }\n\n      this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(${-activeIndex * this.unitWidth + _vector.x}px, 0, 0)`);\n    }\n\n    this.isDragging = true;\n  }\n\n  verticalTransform(_f, _t) {\n    const {\n      from: f,\n      to: t\n    } = this.getFromToInBoundary(_f, _t);\n    const needToAdjust = this.length > 2 && _t !== t;\n\n    if (needToAdjust) {\n      this.prepareVerticalContext(t < f);\n      this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(0, ${-_t * this.unitHeight}px, 0)`);\n    } else {\n      this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(0, ${-t * this.unitHeight}px, 0`);\n    }\n  }\n\n  horizontalTransform(_f, _t) {\n    const {\n      from: f,\n      to: t\n    } = this.getFromToInBoundary(_f, _t);\n    const needToAdjust = this.length > 2 && _t !== t;\n\n    if (needToAdjust) {\n      this.prepareHorizontalContext(t < f);\n      this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(${-_t * this.unitWidth}px, 0, 0)`);\n    } else {\n      this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(${-t * this.unitWidth}px, 0, 0`);\n    }\n  }\n\n  prepareVerticalContext(lastToFirst) {\n    if (lastToFirst) {\n      this.renderer.setStyle(this.firstEl, 'top', `${this.length * this.unitHeight}px`);\n      this.renderer.setStyle(this.lastEl, 'top', null);\n    } else {\n      this.renderer.setStyle(this.firstEl, 'top', null);\n      this.renderer.setStyle(this.lastEl, 'top', `${-this.unitHeight * this.length}px`);\n    }\n  }\n\n  prepareHorizontalContext(lastToFirst) {\n    if (lastToFirst) {\n      this.renderer.setStyle(this.firstEl, 'left', `${this.length * this.unitWidth}px`);\n      this.renderer.setStyle(this.lastEl, 'left', null);\n    } else {\n      this.renderer.setStyle(this.firstEl, 'left', null);\n      this.renderer.setStyle(this.lastEl, 'left', `${-this.unitWidth * this.length}px`);\n    }\n  }\n\n}\n/**\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\r\n */\n\n\nconst NZ_CAROUSEL_CUSTOM_STRATEGIES = new InjectionToken('nz-carousel-custom-strategies');\n/**\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\r\n */\n\nconst NZ_CONFIG_MODULE_NAME = 'carousel';\nlet NzCarouselComponent = /*#__PURE__*/(() => {\n  class NzCarouselComponent {\n    constructor(elementRef, nzConfigService, ngZone, renderer, cdr, platform, resizeService, nzDragService, directionality, customStrategies) {\n      this.nzConfigService = nzConfigService;\n      this.ngZone = ngZone;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.platform = platform;\n      this.resizeService = resizeService;\n      this.nzDragService = nzDragService;\n      this.directionality = directionality;\n      this.customStrategies = customStrategies;\n      this._nzModuleName = NZ_CONFIG_MODULE_NAME;\n      this.nzEffect = 'scrollx';\n      this.nzEnableSwipe = true;\n      this.nzDots = true;\n      this.nzAutoPlay = false;\n      this.nzAutoPlaySpeed = 3000;\n      this.nzTransitionSpeed = 500;\n      /**\r\n       * this property is passed directly to an NzCarouselBaseStrategy\r\n       */\n\n      this.nzStrategyOptions = undefined;\n      this._dotPosition = 'bottom';\n      this.nzBeforeChange = new EventEmitter();\n      this.nzAfterChange = new EventEmitter();\n      this.activeIndex = 0;\n      this.vertical = false;\n      this.transitionInProgress = null;\n      this.dir = 'ltr';\n      this.destroy$ = new Subject();\n      this.gestureRect = null;\n      this.pointerDelta = null;\n      this.isTransiting = false;\n      this.isDragging = false;\n\n      this.onLiClick = index => {\n        if (this.dir === 'rtl') {\n          this.goTo(this.carouselContents.length - 1 - index);\n        } else {\n          this.goTo(index);\n        }\n      };\n      /**\r\n       * Drag carousel.\r\n       */\n\n\n      this.pointerDown = event => {\n        if (!this.isDragging && !this.isTransiting && this.nzEnableSwipe) {\n          this.clearScheduledTransition();\n          this.gestureRect = this.slickListEl.getBoundingClientRect();\n          this.nzDragService.requestDraggingSequence(event).subscribe(delta => {\n            var _a;\n\n            this.pointerDelta = delta;\n            this.isDragging = true;\n            (_a = this.strategy) === null || _a === void 0 ? void 0 : _a.dragging(this.pointerDelta);\n          }, () => {}, () => {\n            if (this.nzEnableSwipe && this.isDragging) {\n              const xDelta = this.pointerDelta ? this.pointerDelta.x : 0; // Switch to another slide if delta is bigger than third of the width.\n\n              if (Math.abs(xDelta) > this.gestureRect.width / 3) {\n                this.goTo(xDelta > 0 ? this.activeIndex - 1 : this.activeIndex + 1);\n              } else {\n                this.goTo(this.activeIndex);\n              }\n\n              this.gestureRect = null;\n              this.pointerDelta = null;\n            }\n\n            this.isDragging = false;\n          });\n        }\n      };\n\n      this.nzDotPosition = 'bottom';\n      this.renderer.addClass(elementRef.nativeElement, 'ant-carousel');\n      this.el = elementRef.nativeElement;\n    }\n\n    set nzDotPosition(value) {\n      this._dotPosition = value;\n\n      if (value === 'left' || value === 'right') {\n        this.vertical = true;\n      } else {\n        this.vertical = false;\n      }\n    }\n\n    get nzDotPosition() {\n      return this._dotPosition;\n    }\n\n    ngOnInit() {\n      this.slickListEl = this.slickList.nativeElement;\n      this.slickTrackEl = this.slickTrack.nativeElement;\n      this.dir = this.directionality.value;\n      this.directionality.change.pipe(takeUntil(this.destroy$)).subscribe(direction => {\n        this.dir = direction;\n        this.markContentActive(this.activeIndex);\n        this.cdr.detectChanges();\n      });\n      this.ngZone.runOutsideAngular(() => {\n        fromEvent(this.slickListEl, 'keydown').pipe(takeUntil(this.destroy$)).subscribe(event => {\n          const {\n            keyCode\n          } = event;\n\n          if (keyCode !== LEFT_ARROW && keyCode !== RIGHT_ARROW) {\n            return;\n          }\n\n          event.preventDefault();\n          this.ngZone.run(() => {\n            if (keyCode === LEFT_ARROW) {\n              this.pre();\n            } else {\n              this.next();\n            }\n\n            this.cdr.markForCheck();\n          });\n        });\n      });\n    }\n\n    ngAfterContentInit() {\n      this.markContentActive(0);\n    }\n\n    ngAfterViewInit() {\n      this.carouselContents.changes.subscribe(() => {\n        this.markContentActive(0);\n        this.layout();\n      });\n      this.resizeService.subscribe().pipe(takeUntil(this.destroy$)).subscribe(() => {\n        this.layout();\n      });\n      this.switchStrategy();\n      this.markContentActive(0);\n      this.layout(); // If embedded in an entry component, it may do initial render at an inappropriate time.\n      // ngZone.onStable won't do this trick\n      // TODO: need to change this.\n\n      Promise.resolve().then(() => {\n        this.layout();\n      });\n    }\n\n    ngOnChanges(changes) {\n      const {\n        nzEffect,\n        nzDotPosition\n      } = changes;\n\n      if (nzEffect && !nzEffect.isFirstChange()) {\n        this.switchStrategy();\n        this.markContentActive(0);\n        this.layout();\n      }\n\n      if (nzDotPosition && !nzDotPosition.isFirstChange()) {\n        this.switchStrategy();\n        this.markContentActive(0);\n        this.layout();\n      }\n\n      if (!this.nzAutoPlay || !this.nzAutoPlaySpeed) {\n        this.clearScheduledTransition();\n      } else {\n        this.scheduleNextTransition();\n      }\n    }\n\n    ngOnDestroy() {\n      this.clearScheduledTransition();\n\n      if (this.strategy) {\n        this.strategy.dispose();\n      }\n\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n\n    next() {\n      this.goTo(this.activeIndex + 1);\n    }\n\n    pre() {\n      this.goTo(this.activeIndex - 1);\n    }\n\n    goTo(index) {\n      if (this.carouselContents && this.carouselContents.length && !this.isTransiting) {\n        const length = this.carouselContents.length;\n        const from = this.activeIndex;\n        const to = (index + length) % length;\n        this.isTransiting = true;\n        this.nzBeforeChange.emit({\n          from,\n          to\n        });\n        this.strategy.switch(this.activeIndex, index).subscribe(() => {\n          this.scheduleNextTransition();\n          this.nzAfterChange.emit(index);\n          this.isTransiting = false;\n        });\n        this.markContentActive(to);\n        this.cdr.markForCheck();\n      }\n    }\n\n    switchStrategy() {\n      if (this.strategy) {\n        this.strategy.dispose();\n      } // Load custom strategies first.\n\n\n      const customStrategy = this.customStrategies ? this.customStrategies.find(s => s.name === this.nzEffect) : null;\n\n      if (customStrategy) {\n        this.strategy = new customStrategy.strategy(this, this.cdr, this.renderer, this.platform);\n        return;\n      }\n\n      this.strategy = this.nzEffect === 'scrollx' ? new NzCarouselTransformStrategy(this, this.cdr, this.renderer, this.platform) : new NzCarouselOpacityStrategy(this, this.cdr, this.renderer, this.platform);\n    }\n\n    scheduleNextTransition() {\n      this.clearScheduledTransition();\n\n      if (this.nzAutoPlay && this.nzAutoPlaySpeed > 0 && this.platform.isBrowser) {\n        this.transitionInProgress = setTimeout(() => {\n          this.goTo(this.activeIndex + 1);\n        }, this.nzAutoPlaySpeed);\n      }\n    }\n\n    clearScheduledTransition() {\n      if (this.transitionInProgress) {\n        clearTimeout(this.transitionInProgress);\n        this.transitionInProgress = null;\n      }\n    }\n\n    markContentActive(index) {\n      this.activeIndex = index;\n\n      if (this.carouselContents) {\n        this.carouselContents.forEach((slide, i) => {\n          if (this.dir === 'rtl') {\n            slide.isActive = index === this.carouselContents.length - 1 - i;\n          } else {\n            slide.isActive = index === i;\n          }\n        });\n      }\n\n      this.cdr.markForCheck();\n    }\n\n    layout() {\n      if (this.strategy) {\n        this.strategy.withCarouselContents(this.carouselContents);\n      }\n    }\n\n  }\n\n  NzCarouselComponent.ɵfac = function NzCarouselComponent_Factory(t) {\n    return new (t || NzCarouselComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NzConfigService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.NzResizeService), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.NzDragService), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.Directionality, 8), ɵngcc0.ɵɵdirectiveInject(NZ_CAROUSEL_CUSTOM_STRATEGIES, 8));\n  };\n\n  NzCarouselComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: NzCarouselComponent,\n    selectors: [[\"nz-carousel\"]],\n    contentQueries: function NzCarouselComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, NzCarouselContentDirective, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.carouselContents = _t);\n      }\n    },\n    viewQuery: function NzCarouselComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 7);\n        ɵngcc0.ɵɵviewQuery(_c1, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.slickList = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.slickTrack = _t.first);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function NzCarouselComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"ant-carousel-vertical\", ctx.vertical)(\"ant-carousel-rtl\", ctx.dir === \"rtl\");\n      }\n    },\n    inputs: {\n      nzEffect: \"nzEffect\",\n      nzEnableSwipe: \"nzEnableSwipe\",\n      nzDots: \"nzDots\",\n      nzAutoPlay: \"nzAutoPlay\",\n      nzAutoPlaySpeed: \"nzAutoPlaySpeed\",\n      nzTransitionSpeed: \"nzTransitionSpeed\",\n      nzStrategyOptions: \"nzStrategyOptions\",\n      nzDotPosition: \"nzDotPosition\",\n      nzDotRender: \"nzDotRender\"\n    },\n    outputs: {\n      nzBeforeChange: \"nzBeforeChange\",\n      nzAfterChange: \"nzAfterChange\"\n    },\n    exportAs: [\"nzCarousel\"],\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c3,\n    decls: 9,\n    vars: 3,\n    consts: [[1, \"slick-initialized\", \"slick-slider\"], [\"tabindex\", \"-1\", 1, \"slick-list\", 3, \"mousedown\", \"touchstart\"], [\"slickList\", \"\"], [1, \"slick-track\"], [\"slickTrack\", \"\"], [\"class\", \"slick-dots\", 3, \"slick-dots-top\", \"slick-dots-bottom\", \"slick-dots-left\", \"slick-dots-right\", 4, \"ngIf\"], [\"renderDotTemplate\", \"\"], [1, \"slick-dots\"], [3, \"slick-active\", \"click\", 4, \"ngFor\", \"ngForOf\"], [3, \"click\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function NzCarouselComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"div\", 1, 2);\n        ɵngcc0.ɵɵlistener(\"mousedown\", function NzCarouselComponent_Template_div_mousedown_1_listener($event) {\n          return ctx.pointerDown($event);\n        })(\"touchstart\", function NzCarouselComponent_Template_div_touchstart_1_listener($event) {\n          return ctx.pointerDown($event);\n        });\n        ɵngcc0.ɵɵelementStart(3, \"div\", 3, 4);\n        ɵngcc0.ɵɵprojection(5);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(6, NzCarouselComponent_ul_6_Template, 2, 9, \"ul\", 5);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(7, NzCarouselComponent_ng_template_7_Template, 2, 1, \"ng-template\", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"slick-vertical\", ctx.nzDotPosition === \"left\" || ctx.nzDotPosition === \"right\");\n        ɵngcc0.ɵɵadvance(6);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.nzDots);\n      }\n    },\n    directives: [ɵngcc5.NgIf, ɵngcc5.NgForOf, ɵngcc5.NgTemplateOutlet],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  __decorate([WithConfig()], NzCarouselComponent.prototype, \"nzEffect\", void 0);\n\n  __decorate([WithConfig(), InputBoolean()], NzCarouselComponent.prototype, \"nzEnableSwipe\", void 0);\n\n  __decorate([WithConfig(), InputBoolean()], NzCarouselComponent.prototype, \"nzDots\", void 0);\n\n  __decorate([WithConfig(), InputBoolean()], NzCarouselComponent.prototype, \"nzAutoPlay\", void 0);\n\n  __decorate([WithConfig(), InputNumber()], NzCarouselComponent.prototype, \"nzAutoPlaySpeed\", void 0);\n\n  __decorate([InputNumber()], NzCarouselComponent.prototype, \"nzTransitionSpeed\", void 0);\n\n  __decorate([WithConfig()], NzCarouselComponent.prototype, \"nzDotPosition\", null);\n\n  return NzCarouselComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\r\n */\n\n\nlet NzCarouselModule = /*#__PURE__*/(() => {\n  class NzCarouselModule {}\n\n  NzCarouselModule.ɵfac = function NzCarouselModule_Factory(t) {\n    return new (t || NzCarouselModule)();\n  };\n\n  NzCarouselModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NzCarouselModule\n  });\n  NzCarouselModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[BidiModule, CommonModule, PlatformModule]]\n  });\n  return NzCarouselModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NzCarouselModule, {\n    declarations: function () {\n      return [NzCarouselComponent, NzCarouselContentDirective];\n    },\n    imports: function () {\n      return [BidiModule, CommonModule, PlatformModule];\n    },\n    exports: function () {\n      return [NzCarouselComponent, NzCarouselContentDirective];\n    }\n  });\n})();\n/**\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\r\n */\n\n/**\r\n * this strategy is very much like NzCarouselTransformStrategy, but it doesn't loop between the first and the last one\r\n */\n\n\nclass NzCarouselTransformNoLoopStrategy extends NzCarouselBaseStrategy {\n  constructor(carouselComponent, cdr, renderer, platform, options) {\n    super(carouselComponent, cdr, renderer, platform, options);\n    this.isTransitioning = false;\n  }\n\n  get vertical() {\n    return this.carouselComponent.vertical;\n  }\n\n  dispose() {\n    this.renderer.setStyle(this.slickTrackEl, 'transform', null);\n    super.dispose();\n  }\n\n  withCarouselContents(contents) {\n    super.withCarouselContents(contents);\n    const carousel = this.carouselComponent;\n    const activeIndex = carousel.activeIndex;\n\n    if (this.platform.isBrowser && this.contents.length) {\n      this.renderer.setStyle(this.slickListEl, 'height', `${this.unitHeight}px`);\n\n      if (this.platform.isBrowser && this.contents.length) {\n        this.renderer.setStyle(this.slickListEl, 'height', `${this.unitHeight}px`);\n\n        if (this.vertical) {\n          this.renderer.setStyle(this.slickTrackEl, 'width', `${this.unitWidth}px`);\n          this.renderer.setStyle(this.slickTrackEl, 'height', `${this.length * this.unitHeight}px`);\n          this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(0, ${-activeIndex * this.unitHeight}px, 0)`);\n        } else {\n          this.renderer.setStyle(this.slickTrackEl, 'height', `${this.unitHeight}px`);\n          this.renderer.setStyle(this.slickTrackEl, 'width', `${this.length * this.unitWidth}px`);\n          this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(${-activeIndex * this.unitWidth}px, 0, 0)`);\n        }\n\n        this.contents.forEach(content => {\n          this.renderer.setStyle(content.el, 'position', 'relative');\n          this.renderer.setStyle(content.el, 'width', `${this.unitWidth}px`);\n          this.renderer.setStyle(content.el, 'height', `${this.unitHeight}px`);\n        });\n      }\n    }\n  }\n\n  switch(_f, _t) {\n    const to = (_t + this.length) % this.length;\n    const transitionSpeed = this.carouselComponent.nzTransitionSpeed;\n    const complete$ = new Subject();\n    this.renderer.setStyle(this.slickTrackEl, 'transition', `transform ${transitionSpeed}ms ease`);\n\n    if (this.vertical) {\n      this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(0, ${-to * this.unitHeight}px, 0)`);\n    } else {\n      this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(${-to * this.unitWidth}px, 0, 0)`);\n    }\n\n    this.isTransitioning = true;\n    setTimeout(() => {\n      // this strategy don't need to do a following adjust\n      this.isTransitioning = false;\n      complete$.next();\n      complete$.complete();\n    }, transitionSpeed);\n    return complete$.asObservable();\n  }\n\n  dragging(vector) {\n    if (this.isTransitioning) {\n      return;\n    }\n\n    const activeIndex = this.carouselComponent.activeIndex;\n\n    if (this.vertical) {\n      this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(0, ${-activeIndex * this.unitHeight + vector.x}px, 0)`);\n    } else {\n      this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(${-activeIndex * this.unitWidth + vector.x}px, 0, 0)`);\n    }\n  }\n\n}\n/**\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\r\n */\n\n\nclass NzCarouselFlipStrategy extends NzCarouselBaseStrategy {\n  withCarouselContents(contents) {\n    super.withCarouselContents(contents);\n\n    if (this.contents) {\n      this.renderer.setStyle(this.slickListEl, 'width', `${this.unitWidth}px`);\n      this.renderer.setStyle(this.slickTrackEl, 'width', `${this.length * this.unitWidth}px`);\n      this.contents.forEach((content, i) => {\n        const cur = this.carouselComponent.activeIndex === i;\n        this.renderer.setStyle(content.el, 'transform', cur ? 'rotateY(0deg)' : 'rotateY(180deg)');\n        this.renderer.setStyle(content.el, 'position', 'relative');\n        this.renderer.setStyle(content.el, 'width', `${this.unitWidth}px`);\n        this.renderer.setStyle(content.el, 'left', `${-this.unitWidth * i}px`);\n        this.renderer.setStyle(content.el, 'transform-style', 'preserve-3d');\n        this.renderer.setStyle(content.el, 'backface-visibility', 'hidden');\n      });\n      timer(this.carouselComponent.nzTransitionSpeed).subscribe(() => {\n        this.contents.forEach(c => this.renderer.setStyle(c.el, 'transition', ['transform 500ms ease 0s']));\n      });\n    }\n  }\n\n  switch(rawF, rawT) {\n    const {\n      from,\n      to\n    } = this.getFromToInBoundary(rawF, rawT);\n    const complete$ = new Subject();\n    const speed = this.carouselComponent.nzTransitionSpeed;\n    timer(speed).subscribe(() => {\n      complete$.next();\n      complete$.complete();\n    });\n\n    if (rawF === rawT) {\n      return complete$;\n    }\n\n    this.contents.forEach((content, i) => {\n      if (i === from) {\n        this.renderer.setStyle(content.el, 'transform', 'rotateY(180deg)');\n      } else if (i === to) {\n        this.renderer.setStyle(content.el, 'transform', 'rotateY(0deg)');\n      }\n    });\n    return complete$.asObservable();\n  }\n\n  dispose() {\n    this.contents.forEach(content => {\n      this.renderer.setStyle(content.el, 'transition', null);\n      this.renderer.setStyle(content.el, 'transform', null);\n      this.renderer.setStyle(content.el, 'width', null);\n      this.renderer.setStyle(content.el, 'left', null);\n      this.renderer.setStyle(content.el, 'transform-style', null);\n      this.renderer.setStyle(content.el, 'backface-visibility', null);\n    });\n    super.dispose();\n  }\n\n}\n/**\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { NZ_CAROUSEL_CUSTOM_STRATEGIES, NzCarouselBaseStrategy, NzCarouselComponent, NzCarouselContentDirective, NzCarouselFlipStrategy, NzCarouselModule, NzCarouselOpacityStrategy, NzCarouselTransformNoLoopStrategy, NzCarouselTransformStrategy }; //# sourceMappingURL=ng-zorro-antd-carousel.js.map","map":null,"metadata":{},"sourceType":"module"}